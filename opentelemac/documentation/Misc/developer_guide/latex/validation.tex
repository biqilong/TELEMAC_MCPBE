%----------------------------------------------------------------------------------------------------
\chapter{Validation}
%----------------------------------------------------------------------------------------------------

This chapter will describe how to use the validation Python scripts.
Those scripts are used to define a VnV (Verification and Validation) test case.
It will describe what to run and what to do with the data from the runs such as
comparison between reference file and results file, comparison with an
analytical solution, comparison with data\ldots

%----------------------------------------------------------------------------------------------------
\section{Structure of Python script}
\label{ref:descVnvStudy}
%----------------------------------------------------------------------------------------------------

Each test case is described using a Python script that must start with
"\verb!vnv_!" and looks like that when empty:

% parameter for Python coloring
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\lstset{language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={VnvStudy, AbstractVnvStudy,_init,_pre,_check_results,_post},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            %
}

\begin{lstlisting}
"""
Validation script for gouttedo
"""
from vvytel.vnv_study import AbstractVnvStudy
from execution.telemac_cas import TelemacCas, get_dico
from data_manip.extraction.telemac_file import TelemacFile

class VnvStudy(AbstractVnvStudy):
    """
    Class for validation
    """

    def _init(self):
        """
        Defining general parameters
        """
        self.rank = 4
        self.tags = ['telemac2d']

    def _pre(self):
        """
        Defining the studies
        """
        pass

    def _check_results(self):
        """
        Check on run results
        """
        pass

    def _post(self):
        """
        Post-treatment processes
        """
        pass
\end{lstlisting}

This defines a class named "\verb!VnvStudy!" which inherits from
"\verb!AbstractVnvStudy!" which is an abstract class for which you need to fill
the following 4 functions:
\begin{itemize}
\item \_init: This is were we define the rank and the tags. The rank defines
  the importance of the test case the rule for the rank is described below.
    While the tag is a system to identify was is tested in the case. This list
    of tags can be find in \verb!validate_telemac.py!
\item \_pre: This is were we will defined the studies, a study is defined by a
  steering file and a module.
\item \_check\_results: This is were we will do checks on the results versus,
  measurements, analytical solutions, reference files\ldots
\item \_post: This were we will do the post-treatment we recommand to use
  function from postel Python module but you can use any Python code.
\end{itemize}

The rank follow the rules below:
\begin{itemize}
\item 0: Minimal validation should last less than an hour and check each
  module.
\item 1: More complete validation should last less than 4 hours.
\item 2: Less than a day (Daily validation).
\item 3: The additional test launch over the WE.
\item 4: Very specific cases run only we are making a new release.
\end{itemize}

%----------------------------------------------------------------------------------------------------
\section{Where to look for examples}
%----------------------------------------------------------------------------------------------------
You can have a look at all the Python script in the examples but here is a
small list of where to find examples on how to do specific actions:
\begin{itemize}
\item For a basic validation case (steering file run in sequential and parallel
  and comparison of sequential vs reference, parallel vs reference and
    sequential vs parallle) as well as a couple examples of post-treatment have
    a look at \verb!examples/telemac2d/gouttedo/vnv_thompson.py!
\item For an example of a validation against an analytical solutions and the
  post-treatment to go with that have a look at
    \verb!examples/telemac2d/thacker/vnv_thacker.py!
\item For an example of the generation of multiple steering file to test a
  range of options have a look at
    \verb!examples/telemac3d/lock-exchange/vnv_lock_exchange_sensibility.py!
\end{itemize}

For examples of extractions and post-treatment have a look at the notebooks (In
notebooks at the root of your \telemacsystem). To run them use jupyter notebook
and run \verb!jupyter notebook notebooks/index.ipynb!.

%----------------------------------------------------------------------------------------------------
\section{How to run validation}
%----------------------------------------------------------------------------------------------------

To run validation use the script "\verb!validate_telemac.py!".
To summarise what you have access to:
\begin{itemize}
\item if you pass the script Python file as argument it will run them otherwise
  it will loop over the ones in the examples folder.
\item if you add -k/--rank or --tags you can specify for which ranks, tags to
  run validation.
\item if you add --vnv-pre/--vnv-run/--vnv-post/--vnv-check-results you can run
only those steps (you can have more than). Just beware that some are necessary
for the others (for example you can not do post treatment if you have not run
the case first). The pre-treatment phase is always run.
\item if you add --report-name=toto it will generate a csv file at the root of
  your \telemacsystem{} containing time informations for each step (pre,
    check\_results) and the run of each study.
\item if you add --clean or --full-clean instead of running it will delete the
  files created by the validation script (this will delete the results of the
    runs).
\item all the options from \verb!runcode.py!. Those will be passed to each run.
\end{itemize}

When running "\verb!validate_telemac.py!" on an already ran VnV case the run
part will not be done if none of the input files (files to read given in the steering file)
or the steering file itself are newer than one the output files (a file that was
generated by the run).

To see all the options run \verb!validate_telemac.py -h!.

%----------------------------------------------------------------------------------------------------
\subsection{Validation on cluster}
%----------------------------------------------------------------------------------------------------

Validation can also the run on cluster or more efficiency.
It will follow this pattern:
\begin{enumerate}
  \item Clean up the examples folder
  \item Launch all the \telma runs via the scheduler
  \item Wait for the jobs to be finished
  \item Launch the epsilons check and the post-treatment
\end{enumerate}

%----------------------------------------------------------------------------------------------------
\subsubsection{Requirements}
%----------------------------------------------------------------------------------------------------

To run validation on a cluster first you'll have to have a configuration with
the following points:
\begin{itemize}
  \item A hpc configuration (see on the website for more information).
  \item The batch submission command must write in a file for each submission
    the id of the submission and the folder of case ';' separated.
\end{itemize}

The procedure below will submit each of the \telma{} runs to the cluster
scheduler. This means that in the best of case your whole validation will be as
long as your longest \telma{} run.

Here is an example for a cluster using slurm (The command is a one line command
it is on multiple line here):
\begin{lstlisting}[language=bash]
cp HPC_STDIN ../;
cd ../;
ret=`sbatch --wckey="P119C:TELEMAC_SYSTEM" < HPC_STDIN`;
id=`echo $ret|tr ' ' '\n'|tail -n 1`;
dir=`pwd`;
echo "$id;$dir" >> $HOME/valid_run_$USETELCFG.log;
echo $ret
\end{lstlisting}

Here is an extract of what the file containing the id looks like:
\begin{verbatim}
30346528;trunk/examples/artemis/G8M/vnv_g8m/vnv_1/eole.intel.dyn
30346529;trunk/examples/artemis/beach/vnv_beach/vnv_1/eole.intel.dyn
30346531;trunk/examples/artemis/beach/vnv_beach/vnv_2/eole.intel.dyn
30346534;trunk/examples/artemis/bj78/vnv_bj78/vnv_1/eole.intel.dyn
30346535;trunk/examples/artemis/bj78/vnv_bj78/vnv_2/eole.intel.dyn
30346537;trunk/examples/artemis/bosse/vnv_bosse/vnv_1/eole.intel.dyn
\end{verbatim}

Then you need a script that can wait for a list of jobs to be finished.
Here is an example of such a script for cluster using slurm:

\begin{lstlisting}[language=python,basicstyle=\footnotesize,keywordstyle=\color{blue}\footnotesize]
#!/usr/bin/env python3
from argparse import ArgumentParser
import time
import subprocess
import re
import sys

def check_job(job_id, call_count=0):
    """
    Return a job status

    @param job_id (str) Job id of the job to check
    @parma call_count (int) Recursive number of call if 5
                            is reached returns -1

    @returns (int) 1 if completed
                   -1 if job crashed
                   0 otherwise (job still running or pending)
    """
    cmd = "sacct -j {} -o JobID,State -P".format(job_id)

    # Scontrol will give us information on the job
    # TODO: Extract more than just the path ?
    #       We could get the listing...
    try:
        tmp = subprocess.check_output(cmd, shell=True)
    except:
        sleep(1)
        tmp = subprocess.check_output(cmd, shell=True)
    output = tmp.decode('utf-8')
    # In case the return is not as it should trying
    # again after 5 tries returning crashed
    if len(output.split('\n')) < 3:
        if call_count == 5:
            return -1
        else:
            return check_job(job_id, call_count=call_count+1)

    # Extract line containing status (second one)
    line = output.split('\n')[1]
    # Line should be something like that: 30346693|COMPLETED
    state = line.split('|')[1]

    if state == 'COMPLETED':
        return 1
    elif state in ['CANCELLED', 'FAILED',
                   'TIMEOUT', 'DEADLINE']:
        if state == 'TIMEOUT':
            print('Need to increase walltime for '+job_id)
        return -1
    else:
        return 0

def main():
    """
    Main function
    """
    parser = ArgumentParser(\
        'Wait that all the jobs given in the files are finished')

    parser.add_argument("input_file",
                        help="Contains a list of ; separarated"\
                             "string (Command and id)")

    options = parser.parse_args()

    jobs = {}
    # Building dictionary of jobs:
    with open(options.input_file, 'r') as f:
        for line in f.readlines():
            job_id, command = line.split(';')
            if job_id == '':
                print("Error in job id file")
                sys.exit(1)
            jobs[job_id] = command


    # Check job status
    failed = []
    prev_len = 0
    actual_len = len(jobs)
    wait_time = 10

    while actual_len != 0:
        if prev_len != actual_len:
            print("Remaining jobs: ", len(jobs))
        t1 = time.time()
        for job_id in list(jobs.keys()):
            state = check_job(job_id)
            # Job crashed
            if state == -1:
                failed.append(jobs[job_id])
                del jobs[job_id]
            # Job is done
            elif state == 1:
                del jobs[job_id]
            # Otherwise job is still running
        t2 = time.time()
        # Only wait if the loop was done in less than a second
        if (t2 - t1) < wait_time:
            time.sleep(wait_time)
        # Update info on len
        prev_len = actual_len
        actual_len = len(jobs)

    if failed != []:
        print("The following job failed in the "
              "following folders:\n")
        for fail in failed:
            print("~"*40+"\n"+fail+"\n")
        sys.exit(1)

    sys.exit(0)

if __name__ == '__main__':
    main()
\end{lstlisting}

%----------------------------------------------------------------------------------------------------
\subsubsection{Run commands}
%----------------------------------------------------------------------------------------------------

The procedure to run is the following:
\begin{enumerate}
  \item Run '\verb!validate\_telemac.py! \textit{valid\_options} \verb!--clean!'.
  \item Run '\verb!validate\_telemac.py! \textit{valid\_options} \textit{hpc\_options}\verb! --vnv-run!'.
  \item Run your script that wait for the jobs to be finished.
  \item Run '\verb!validate\_telemac.py! \textit{valid\_options} \verb!--vnv-check --vnv-post!'.
\end{enumerate}

Replacing:
\begin{itemize}
  \item \textit{valid\_options} by the options for your validation (--tag, -k,
    --bypass\ldots).
  \item \textit{hpc\_options} by the options you would give a hpc \telma{} run on
    your cluster (--queue, --nctile, --walltime, --jobname\ldots).
\end{itemize}
